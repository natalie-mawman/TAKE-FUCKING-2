import { jwtDecode } from "jwt-decode";
import * as JSON from "@ungap/raw-json";
function buildTokenState(tokens) {
    return {
        state: tokens && {
            tokens,
            claims: jwtDecode(tokens.auth_token),
        },
        headers: headers(tokens),
    };
}
function buildUser(state) {
    const claims = state.state?.claims;
    if (claims) {
        return {
            id: claims.sub,
            email: claims.email,
        };
    }
}
function isExpired(state) {
    const claims = state.state?.claims;
    if (claims) {
        const now = Date.now() / 1000;
        if (claims.exp < now) {
            return true;
        }
    }
    return false;
}
/// Returns the refresh token if should refresh.
function shouldRefresh(tokenState) {
    const state = tokenState.state;
    if (state && state.claims.exp - 60 < Date.now() / 1000) {
        return state.tokens?.refresh_token ?? undefined;
    }
}
export class FetchError extends Error {
    status;
    constructor(status, msg) {
        super(msg);
        this.status = status;
    }
    static async from(response) {
        let body;
        try {
            body = await response.text();
        }
        catch { }
        return new FetchError(response.status, `FetchError(status: ${response.status} - ${response.statusText}, ${body})`);
    }
    isClient() {
        return this.status >= 400 && this.status < 500;
    }
    isServer() {
        return this.status >= 500;
    }
}
function formatCompareOp(op) {
    switch (op) {
        case "equal":
            return "$eq";
        case "notEqual":
            return "$ne";
        case "lessThan":
            return "$lt";
        case "lessThanEqual":
            return "$lte";
        case "greaterThan":
            return "$gt";
        case "greaterThanEqual":
            return "$gte";
        case "like":
            return "$like";
        case "regexp":
            return "$re";
    }
}
export class CreateOperation {
    client;
    apiName;
    record;
    constructor(client, apiName, record) {
        this.client = client;
        this.apiName = apiName;
        this.record = record;
    }
    async query() {
        const response = await this.client.fetch(`${recordApiBasePath}/${this.apiName}`, {
            method: "POST",
            body: JSON.stringify(this.record),
            headers: jsonContentTypeHeader,
        });
        return parseJSON(await response.text()).ids[0];
    }
    toJSON() {
        return {
            Create: {
                api_name: this.apiName,
                value: this.record,
            },
        };
    }
}
export class UpdateOperation {
    client;
    apiName;
    id;
    record;
    constructor(client, apiName, id, record) {
        this.client = client;
        this.apiName = apiName;
        this.id = id;
        this.record = record;
    }
    async query() {
        await this.client.fetch(`${recordApiBasePath}/${this.apiName}/${this.id}`, {
            method: "PATCH",
            body: JSON.stringify(this.record),
            headers: jsonContentTypeHeader,
        });
    }
    toJSON() {
        return {
            Update: {
                api_name: this.apiName,
                record_id: this.id,
                value: this.record,
            },
        };
    }
}
export class DeleteOperation {
    client;
    apiName;
    id;
    constructor(client, apiName, id) {
        this.client = client;
        this.apiName = apiName;
        this.id = id;
    }
    async query() {
        await this.client.fetch(`${recordApiBasePath}/${this.apiName}/${this.id}`, {
            method: "DELETE",
        });
    }
    toJSON() {
        return {
            Delete: {
                api_name: this.apiName,
                record_id: this.id,
            },
        };
    }
}
export class ReadOperation {
    client;
    apiName;
    id;
    opt;
    constructor(client, apiName, id, opt) {
        this.client = client;
        this.apiName = apiName;
        this.id = id;
        this.opt = opt;
    }
    async query() {
        const expand = this.opt?.expand;
        const response = await this.client.fetch(expand
            ? `${recordApiBasePath}/${this.apiName}/${this.id}?expand=${expand.join(",")}`
            : `${recordApiBasePath}/${this.apiName}/${this.id}`);
        return parseJSON(await response.text());
    }
}
export class ListOperation {
    client;
    apiName;
    opts;
    constructor(client, apiName, opts) {
        this.client = client;
        this.apiName = apiName;
        this.opts = opts;
    }
    async query() {
        const params = new URLSearchParams();
        const pagination = this.opts?.pagination;
        if (pagination) {
            const cursor = pagination.cursor;
            if (cursor)
                params.append("cursor", cursor);
            const limit = pagination.limit;
            if (limit)
                params.append("limit", limit.toString());
            const offset = pagination.offset;
            if (offset)
                params.append("offset", offset.toString());
        }
        const order = this.opts?.order;
        if (order)
            params.append("order", order.join(","));
        if (this.opts?.count)
            params.append("count", "true");
        const expand = this.opts?.expand;
        if (expand)
            params.append("expand", expand.join(","));
        const filters = this.opts?.filters;
        if (filters) {
            for (const filter of filters) {
                addFiltersToParams(params, "filter", filter);
            }
        }
        const response = await this.client.fetch(`${recordApiBasePath}/${this.apiName}?${params}`);
        return parseJSON(await response.text());
    }
}
/// Provides CRUD access to records through TrailBase's record API.
export class RecordApiImpl {
    client;
    name;
    constructor(client, name) {
        this.client = client;
        this.name = name;
    }
    async list(opts) {
        return new ListOperation(this.client, this.name, opts).query();
    }
    listOp(opts) {
        return new ListOperation(this.client, this.name, opts);
    }
    async read(id, opt) {
        return new ReadOperation(this.client, this.name, id, opt).query();
    }
    readOp(id, opt) {
        return new ReadOperation(this.client, this.name, id, opt);
    }
    async create(record) {
        return new CreateOperation(this.client, this.name, record).query();
    }
    createOp(record) {
        return new CreateOperation(this.client, this.name, record);
    }
    async createBulk(records) {
        const response = await this.client.fetch(`${recordApiBasePath}/${this.name}`, {
            method: "POST",
            body: JSON.stringify(records),
            headers: jsonContentTypeHeader,
        });
        return parseJSON(await response.text()).ids;
    }
    async update(id, record) {
        return new UpdateOperation(this.client, this.name, id, record).query();
    }
    updateOp(id, record) {
        return new UpdateOperation(this.client, this.name, id, record);
    }
    async delete(id) {
        return new DeleteOperation(this.client, this.name, id).query();
    }
    deleteOp(id) {
        return new DeleteOperation(this.client, this.name, id);
    }
    async subscribe(id) {
        return await this.subscribeImpl(id);
    }
    async subscribeAll(opts) {
        return await this.subscribeImpl("*", opts);
    }
    async subscribeImpl(id, opts) {
        const params = new URLSearchParams();
        const filters = opts?.filters ?? [];
        if (filters.length > 0) {
            for (const filter of filters) {
                addFiltersToParams(params, "filter", filter);
            }
        }
        const response = await this.client.fetch(filters.length > 0
            ? `${recordApiBasePath}/${this.name}/subscribe/${id}?${params}`
            : `${recordApiBasePath}/${this.name}/subscribe/${id}`);
        const body = response.body;
        if (!body) {
            throw Error("Subscription reader is null.");
        }
        const decoder = new TextDecoder();
        const transformStream = new TransformStream({
            transform(chunk, controller) {
                const messages = decoder.decode(chunk).trimEnd().split("\n\n");
                for (const msg of messages) {
                    if (msg.startsWith("data: ")) {
                        controller.enqueue(JSON.parse(msg.substring(6)));
                    }
                }
            },
            flush(controller) {
                controller.terminate();
            },
        });
        return body.pipeThrough(transformStream);
    }
}
class ThinClient {
    base;
    constructor(base) {
        this.base = base;
    }
    async fetch(path, headers, init) {
        // NOTE: We need to merge the headers in such a complicated fashion
        // to avoid user-provided `init` with headers unintentionally suppressing
        // the credentials.
        const response = await fetch(this.base ? new URL(path, this.base) : path, {
            credentials: isDev ? "include" : "same-origin",
            ...init,
            headers: init
                ? {
                    ...headers,
                    ...init?.headers,
                }
                : headers,
        });
        return response;
    }
}
/// Client for interacting with TrailBase auth and record APIs.
class ClientImpl {
    _client;
    _authChange;
    _tokenState;
    constructor(baseUrl, opts) {
        this._client = new ThinClient(baseUrl ? new URL(baseUrl) : undefined);
        this._authChange = opts?.onAuthChange;
        const tokens = opts?.tokens;
        // Note: this is a double assignment to _tokenState to ensure the linter
        // that it's really initialized in the constructor.
        this._tokenState = this.setTokenState(buildTokenState(tokens), true);
        if (tokens?.refresh_token !== undefined) {
            // Validate session. This is currently async, which allows to initialize
            // a Client synchronously from invalid tokens. We may want to consider
            // offering a safer async initializer to avoid "racy" behavior. Especially,
            // when the auth token is valid while the session has already been closed.
            this.checkAuthStatus()
                .then((tokens) => {
                if (tokens === undefined) {
                    // In this case, the auth state has changed, so we should invoke the callback.
                    this.setTokenState(buildTokenState(undefined), false);
                }
                else {
                    // In this case, the auth state has remained the same, we're merely
                    // updating the reminted auth token.
                    this.setTokenState(buildTokenState(tokens), true);
                }
            })
                .catch(console.error);
        }
    }
    get base() {
        return this._client.base;
    }
    /// Low-level access to tokens (auth, refresh, csrf) useful for persisting them.
    tokens = () => this._tokenState?.state?.tokens;
    /// Provides current user.
    user = () => buildUser(this._tokenState);
    /// Provides current user.
    headers = () => this._tokenState.headers;
    /// Construct accessor for Record API with given name.
    records(name) {
        return new RecordApiImpl(this, name);
    }
    /// Execute a batch query.
    async execute(operations, transaction = true) {
        const response = await this.fetch(transactionApiBasePath, {
            method: "POST",
            body: JSON.stringify({ operations, transaction }),
            headers: jsonContentTypeHeader,
        });
        return parseJSON(await response.text()).ids;
    }
    avatarUrl(userId) {
        const id = userId ?? this.user()?.id;
        if (id) {
            return `${authApiBasePath}/avatar/${id}`;
        }
        return undefined;
    }
    async login(email, password) {
        const response = await this.fetch(`${authApiBasePath}/login`, {
            method: "POST",
            body: JSON.stringify({
                email: email,
                password: password,
            }),
            headers: jsonContentTypeHeader,
        });
        this.setTokenState(buildTokenState((await response.json())));
    }
    async logout() {
        try {
            const refresh_token = this._tokenState.state?.tokens.refresh_token;
            if (refresh_token) {
                await this.fetch(`${authApiBasePath}/logout`, {
                    method: "POST",
                    body: JSON.stringify({
                        refresh_token,
                    }),
                    headers: jsonContentTypeHeader,
                });
            }
            else {
                await this.fetch(`${authApiBasePath}/logout`);
            }
        }
        catch (err) {
            console.debug(err);
        }
        this.setTokenState(buildTokenState(undefined));
        return true;
    }
    async deleteUser() {
        await this.fetch(`${authApiBasePath}/delete`);
        this.setTokenState(buildTokenState(undefined));
    }
    async changeEmail(email) {
        await this.fetch(`${authApiBasePath}/change_email`, {
            method: "POST",
            body: JSON.stringify({
                new_email: email,
            }),
            headers: jsonContentTypeHeader,
        });
    }
    /// This will call the status endpoint, which validates any provided tokens
    /// but also hoists any tokens provided as cookies into a JSON response.
    async checkAuthStatus() {
        const response = await this.fetch(`${authApiBasePath}/status`, {
            throwOnError: false,
        });
        if (response.ok) {
            const status = await response.json();
            const auth_token = status.auth_token;
            if (auth_token) {
                return {
                    auth_token,
                    refresh_token: status.refresh_token,
                    csrf_token: status.csrf_token,
                };
            }
        }
        return undefined;
    }
    async checkCookies() {
        const tokens = await this.checkAuthStatus();
        if (tokens) {
            const newState = buildTokenState(tokens);
            this.setTokenState(newState);
            return newState.state?.tokens;
        }
    }
    async refreshAuthToken() {
        const refreshToken = shouldRefresh(this._tokenState);
        if (refreshToken) {
            // Note: refreshTokenImpl will auto-logout on 401.
            this.setTokenState(await this.refreshTokensImpl(refreshToken));
        }
    }
    async refreshTokensImpl(refreshToken) {
        const response = await this._client.fetch(`${authApiBasePath}/refresh`, this._tokenState.headers, {
            method: "POST",
            body: JSON.stringify({
                refresh_token: refreshToken,
            }),
            headers: jsonContentTypeHeader,
        });
        if (!response.ok) {
            if (response.status === 401) {
                this.logout();
            }
            throw await FetchError.from(response);
        }
        return buildTokenState({
            ...(await response.json()),
            refresh_token: refreshToken,
        });
    }
    setTokenState(state, skipCb = false) {
        this._tokenState = state;
        if (!skipCb) {
            this._authChange?.(this, buildUser(state));
        }
        if (isExpired(state)) {
            // This can happen on initial construction, i.e. if a client is
            // constructed from older, persisted tokens.
            console.debug(`Set token state (expired)`);
        }
        return this._tokenState;
    }
    /// Fetches data from TrailBase endpoints, e.g.:
    ///    const response = await client.fetch("/api/auth/v1/status");
    ///
    /// Unlike native fetch, will throw in case !response.ok.
    async fetch(path, init) {
        let tokenState = this._tokenState;
        const refreshToken = shouldRefresh(tokenState);
        if (refreshToken) {
            tokenState = this.setTokenState(await this.refreshTokensImpl(refreshToken));
        }
        try {
            const response = await this._client.fetch(path, tokenState.headers, init);
            if (!response.ok && (init?.throwOnError ?? true)) {
                throw await FetchError.from(response);
            }
            return response;
        }
        catch (err) {
            if (err instanceof TypeError) {
                console.debug(`Connection refused ${err}. TrailBase down or CORS?`);
            }
            throw err;
        }
    }
}
/// Initialize a new TrailBase client.
export function initClient(site, opts) {
    return new ClientImpl(site, opts);
}
/// Asynchronizly initialize a new TrailBase client trying to convert any
/// potentially existing cookies into an authenticated client.
export async function initClientFromCookies(site, opts) {
    const client = new ClientImpl(site, opts);
    // Prefer explicit tokens. When given, do not update/refresh infinite recursion
    // with `($token) => Client` factories.
    if (!client.tokens()) {
        try {
            await client.checkCookies();
        }
        catch (err) {
            console.debug("No valid cookies found: ", err);
        }
    }
    return client;
}
const recordApiBasePath = "/api/records/v1";
const authApiBasePath = "/api/auth/v1";
const transactionApiBasePath = "/api/transaction/v1/execute";
export function filePath(apiName, recordId, columnName) {
    return `${recordApiBasePath}/${apiName}/${recordId}/file/${columnName}`;
}
export function filesPath(apiName, recordId, columnName, fileName) {
    return `${recordApiBasePath}/${apiName}/${recordId}/files/${columnName}/${fileName}`;
}
function _isDev() {
    const env = import.meta.env;
    const key = "DEV";
    const isDev = env?.[key] ?? false;
    return isDev;
}
const isDev = _isDev();
function headers(tokens) {
    if (tokens) {
        const { auth_token, refresh_token, csrf_token } = tokens;
        return {
            ...(auth_token && {
                Authorization: `Bearer ${auth_token}`,
            }),
            ...(refresh_token && {
                "Refresh-Token": refresh_token,
            }),
            ...(csrf_token && {
                "CSRF-Token": csrf_token,
            }),
        };
    }
    return {};
}
const jsonContentTypeHeader = {
    "Content-Type": "application/json",
};
export function textEncode(s) {
    return new TextEncoder().encode(s);
}
export function textDecode(ar) {
    return new TextDecoder().decode(ar);
}
/// Decode a base64 string to bytes.
export function base64Decode(base64) {
    return atob(base64);
}
/// Decode a "url-safe" base64 string to bytes.
export function urlSafeBase64Decode(base64) {
    return base64Decode(base64.replace(/_/g, "/").replace(/-/g, "+"));
}
/// Encode an arbitrary string input as base64 string.
export function base64Encode(s) {
    return btoa(s);
}
/// Encode an arbitrary string input as a "url-safe" base64 string.
export function urlSafeBase64Encode(s) {
    return base64Encode(s).replace(/\//g, "_").replace(/\+/g, "-");
}
export function asyncBase64Encode(blob) {
    return new Promise((resolve, _) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsDataURL(blob);
    });
}
function addFiltersToParams(params, path, filter) {
    if ("and" in filter) {
        for (const [i, f] of filter.and.entries()) {
            addFiltersToParams(params, `${path}[$and][${i}]`, f);
        }
    }
    else if ("or" in filter) {
        for (const [i, f] of filter.or.entries()) {
            addFiltersToParams(params, `${path}[$or][${i}]`, f);
        }
    }
    else {
        const f = filter;
        const op = f.op;
        if (op) {
            params.append(`${path}[${f.column}][${formatCompareOp(op)}]`, f.value);
        }
        else {
            params.append(`${path}[${f.column}]`, f.value);
        }
    }
}
export const exportedForTesting = isDev
    ? {
        base64Decode,
        base64Encode,
    }
    : undefined;
BigInt.prototype.toJSON = function () {
    return JSON.rawJSON(this.toString());
};
function parseJSON(text) {
    function reviver(_key, value, context) {
        if (typeof value === "number" &&
            Number.isInteger(value) &&
            !Number.isSafeInteger(value)) {
            // Ignore the value because it has already lost precision
            return BigInt(context.source);
        }
        return value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return JSON.parse(text, reviver);
}
