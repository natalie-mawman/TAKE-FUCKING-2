export type User = {
    id: string;
    email: string;
};
export type Pagination = {
    cursor?: string;
    limit?: number;
    offset?: number;
};
export type ListResponse<T> = {
    cursor?: string;
    records: T[];
    total_count?: number;
};
export type Tokens = {
    auth_token: string;
    refresh_token: string | null;
    csrf_token: string | null;
};
export type Event = {
    Insert: object;
} | {
    Update: object;
} | {
    Delete: object;
} | {
    Error: string;
};
export type FetchOptions = RequestInit & {
    throwOnError?: boolean;
};
export declare class FetchError extends Error {
    status: number;
    constructor(status: number, msg: string);
    static from(response: Response): Promise<FetchError>;
    isClient(): boolean;
    isServer(): boolean;
}
export interface FileUpload {
    content_type?: null | string;
    filename?: null | string;
    mime_type?: null | string;
    objectstore_path: string;
}
export type CompareOp = "equal" | "notEqual" | "lessThan" | "lessThanEqual" | "greaterThan" | "greaterThanEqual" | "like" | "regexp";
export type Filter = {
    column: string;
    op?: CompareOp;
    value: string;
};
export type And = {
    and: FilterOrComposite[];
};
export type Or = {
    or: FilterOrComposite[];
};
export type FilterOrComposite = Filter | And | Or;
export type RecordId = string | number;
interface CreateOp {
    Create: {
        api_name: string;
        value: Record<string, unknown>;
    };
}
interface UpdateOp {
    Update: {
        api_name: string;
        record_id: RecordId;
        value: Record<string, unknown>;
    };
}
interface DeleteOp {
    Delete: {
        api_name: string;
        record_id: RecordId;
    };
}
export interface DeferredOperation<ResponseType> {
    query(): Promise<ResponseType>;
}
export interface DeferredMutation<ResponseType> extends DeferredOperation<ResponseType> {
}
export declare class CreateOperation<T = Record<string, unknown>> implements DeferredMutation<RecordId> {
    private readonly client;
    private readonly apiName;
    private readonly record;
    constructor(client: Client, apiName: string, record: Partial<T>);
    query(): Promise<RecordId>;
    protected toJSON(): CreateOp;
}
export declare class UpdateOperation<T = Record<string, unknown>> implements DeferredMutation<void> {
    private readonly client;
    private readonly apiName;
    private readonly id;
    private readonly record;
    constructor(client: Client, apiName: string, id: RecordId, record: Partial<T>);
    query(): Promise<void>;
    protected toJSON(): UpdateOp;
}
export declare class DeleteOperation implements DeferredMutation<void> {
    private readonly client;
    private readonly apiName;
    private readonly id;
    constructor(client: Client, apiName: string, id: RecordId);
    query(): Promise<void>;
    protected toJSON(): DeleteOp;
}
export interface ReadOpts {
    expand?: string[];
}
export declare class ReadOperation<T = Record<string, unknown>> implements DeferredOperation<T> {
    private readonly client;
    private readonly apiName;
    private readonly id;
    private readonly opt?;
    constructor(client: Client, apiName: string, id: RecordId, opt?: ReadOpts | undefined);
    query(): Promise<T>;
}
export interface ListOpts {
    pagination?: Pagination;
    order?: string[];
    filters?: FilterOrComposite[];
    count?: boolean;
    expand?: string[];
}
export declare class ListOperation<T = Record<string, unknown>> implements DeferredOperation<ListResponse<T>> {
    private readonly client;
    private readonly apiName;
    private readonly opts?;
    constructor(client: Client, apiName: string, opts?: ListOpts | undefined);
    query(): Promise<ListResponse<T>>;
}
export interface SubscribeOpts {
    filters?: FilterOrComposite[];
}
export interface RecordApi<T = Record<string, unknown>> {
    list(opts?: ListOpts): Promise<ListResponse<T>>;
    listOp(opts?: ListOpts): ListOperation<T>;
    read(id: RecordId, opt?: ReadOpts): Promise<T>;
    readOp(id: RecordId, opt?: ReadOpts): ReadOperation<T>;
    create(record: T): Promise<RecordId>;
    createOp(record: T): CreateOperation<T>;
    createBulk(records: T[]): Promise<RecordId[]>;
    update(id: RecordId, record: Partial<T>): Promise<void>;
    updateOp(id: RecordId, record: Partial<T>): UpdateOperation;
    delete(id: RecordId): Promise<void>;
    deleteOp(id: RecordId): DeleteOperation;
    subscribe(id: RecordId): Promise<ReadableStream<Event>>;
    subscribeAll(opts?: SubscribeOpts): Promise<ReadableStream<Event>>;
}
export declare class RecordApiImpl<T = Record<string, unknown>> implements RecordApi<T> {
    private readonly client;
    private readonly name;
    constructor(client: Client, name: string);
    list(opts?: ListOpts): Promise<ListResponse<T>>;
    listOp(opts?: ListOpts): ListOperation<T>;
    read<T = Record<string, unknown>>(id: RecordId, opt?: ReadOpts): Promise<T>;
    readOp(id: RecordId, opt?: ReadOpts): ReadOperation<T>;
    create(record: T): Promise<RecordId>;
    createOp(record: T): CreateOperation<T>;
    createBulk<T = Record<string, unknown>>(records: T[]): Promise<RecordId[]>;
    update(id: RecordId, record: Partial<T>): Promise<void>;
    updateOp(id: RecordId, record: Partial<T>): UpdateOperation<T>;
    delete(id: RecordId): Promise<void>;
    deleteOp(id: RecordId): DeleteOperation;
    subscribe(id: RecordId): Promise<ReadableStream<Event>>;
    subscribeAll(opts?: SubscribeOpts): Promise<ReadableStream<Event>>;
    private subscribeImpl;
}
export interface ClientOptions {
    tokens?: Tokens;
    onAuthChange?: (client: Client, user?: User) => void;
}
export interface Client {
    get base(): URL | undefined;
    tokens(): Tokens | undefined;
    user(): User | undefined;
    headers(): HeadersInit;
    records<T = Record<string, unknown>>(name: string): RecordApi<T>;
    avatarUrl(userId?: string): string | undefined;
    login(email: string, password: string): Promise<void>;
    logout(): Promise<boolean>;
    deleteUser(): Promise<void>;
    checkCookies(): Promise<Tokens | undefined>;
    refreshAuthToken(): Promise<void>;
    fetch(path: string, init?: FetchOptions): Promise<Response>;
    execute(operations: (CreateOperation | UpdateOperation | DeleteOperation)[], transaction?: boolean): Promise<RecordId[]>;
}
export declare function initClient(site?: URL | string, opts?: ClientOptions): Client;
export declare function initClientFromCookies(site?: URL | string, opts?: ClientOptions): Promise<Client>;
export declare function filePath(apiName: string, recordId: RecordId, columnName: string): string;
export declare function filesPath(apiName: string, recordId: RecordId, columnName: string, fileName: string): string;
export declare function textEncode(s: string): Uint8Array;
export declare function textDecode(ar: Uint8Array): string;
export declare function base64Decode(base64: string): string;
export declare function urlSafeBase64Decode(base64: string): string;
export declare function base64Encode(s: string): string;
export declare function urlSafeBase64Encode(s: string): string;
export declare function asyncBase64Encode(blob: Blob): Promise<string>;
export declare const exportedForTesting: {
    base64Decode: typeof base64Decode;
    base64Encode: typeof base64Encode;
} | undefined;
declare global {
    interface BigInt {
        toJSON(): unknown;
    }
}
export {};
